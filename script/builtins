if (word(2 $loadinfo()) != [pf]) {
	load -pf $word(1 $loadinfo());
	return;
};

#	Copyright (c) 2005 David B. Kratter (BlackJac@EFNet)
#
#	Version: 1.1.2005.03.29.1
#
#	This script ensures backward-compatibility with epic4-2.2 by adding the
#	following commands, functions and sets that have been removed from epic5.
#	In places where exact duplication of the behavior of epic4-2.2 is not
#	possible or practical, a close approximation of the original behavior has
#	been made.
#
#	COMMANDS:
#		BYE, DATE, EXIT, HOST, IRCHOST, IRCNAME, LEAVE, REALNAME, SAVE,
#		SIGNOFF, WHOWAS
#
#	FUNCTIONS:
#		WINBOUND, WINCURSORLINE, WINLEVEL, WINNAM, WINNICKLIST, WINNUM,
#		WINQUERY, WINREFS, WINSCROLLBACKSIZE, WINSERV, WINSTATSIZE,
#		WINVISIBLE
#
#	SETS:
#		AUTO_REJOIN, AUTO_REJOIN_DELAY, AUTO_UNMARK_AWAY, AUTO_WHOWAS,
#		BEEP_ON_MSG, COMMAND_MODE, DCC_TIMEOUT, FULL_STATUS_LINE,
#		NUM_OF_WHOWAS, REVERSE_STATUS_LINE, SHOW_END_OF_MSGS,
#		SHOW_WHO_HOPCOUNT, VERBOSE_CTCP
#
#	The following new commands and functions have been added for additional
#	functionality:
#
#	COMMANDS:
#		ADDSET - an interface to $symbolctl() to create your own /SETs
#			 example: addset <name> <type> [<script>]
#		DELSET - an interface to $symbolctl() to delete your own /SETs
#			 example: delset <name>

package builtins;

# COMMANDS

alias addset (name, type, args) {
	if (@name && type) {
		@ symbolctl(create $name);
		@ symbolctl(set $name 1 builtin_variable type $type);
		if (args) {
			@ symbolctl(set $name 1 builtin_variable script $args);
		};
	};
};

alias bye (...) {
	//quit $*;
};

alias date (...) {
	//time $*;
};

alias delset (name, void) {
	if (@name) {
		@ symbolctl(delete $name builtin_variable);
	};
};

alias exit (...) {
	//quit $*;
};

alias host (...) {
	//userhost $*;
};

alias irchost (...) {
	//hostname $*;
};

alias ircname (...) {
	//set realname $*;
};

alias leave (...) {
	//part $*;
};

alias realname (...) {
	//set realname $*;
};

stub alias save -pf save;

alias signoff (...) {
	//quit $*;
};

alias whowas (nick, number default "$num_of_whowas", void) {
	//whowas $nick $number;
};

# FUNCTIONS

alias winbound (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) bind_channel);
};

alias wincursorline (winnum default 0, void) {
	if ((:cursorline = windowctl(get $windowctl(refnum $winnum) cursor)) > -1) {
		return $cursorline;
	};
	return -1;
};

alias winlevel (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) window_level);
};

alias winnam (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) name);
};

alias winnicklist (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) nicklist);
};

alias winnum (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) refnum);
};

alias winquery (winnum default 0, void) {
	return $windowctl(get $windowctl(refnum $winnum) query);
};

alias winrefs (void) {
	return $windowctl(refnums);
};

alias winscrollbacksize (winnum default 0, void) {
	if ((:scrollbacksize = windowctl(get $windowctl(refnum $winnum) display_buffer_size)) > -1) {
		return $scrollbacksize;
	};
	return -1;
};

alias winserv (winnum default 0, void) {
	if ((:serv = windowctl(get $windowctl(refnum $winnum) server)) > -3) {
		return $serv;
	};
	return -1;
};

alias winstatsize (winnum default 0, void) {
	if ((:statsize = windowctl(get $windowctl(refnum $winnum) double)) > -1) {
		return ${statsize + 1};
	};
	return -1;
};

alias winvisible (winnum default 0, void) {
	if ((:visible = windowctl(get $windowctl(refnum $winnum) visible)) > -1) {
		return $visible;
	};
	return -1;
};

# HOOKS

^on ^send_public "*" {
	echo ${!iscurchan($0) ? [$0] : []}> $1-;
};

# SETS

# AUTO_REJOIN, AUTO_REJOIN_DELAY

addset auto_rejoin bool {
	if ([$0] == [on]) {
		^on #-kick 1 '$$servernick() *' {
			${auto_rejoin_delay ? [timer -w $winnum() $auto_rejoin_delay] : [defer]} join $2;
		};
	} else {
		^on #-kick 1 -'$$servernick() *';
	};
};

set auto_rejoin off;

addset auto_rejoin_delay int;

set auto_rejoin_delay 0;

# AUTO_UNMARK_AWAY

addset auto_unmark_away bool {
	if ([$0] == [on]) {
		^on #-input 1 "/*" {
			if (A && findw($0 /me /msg /notice /say) > -1) {
				away;
			};
		};
		^on #-input 1 "*" {
			if (A) {
				away;
			};
		};
	} else {
		^on #-input 1 -"/*";
		^on #-input 1 -"*";
	};
};

set auto_unmark_away off;

# AUTO_WHOWAS

addset auto_whowas bool {
	if ([$0] == [on]) {
		^on #-401 1 "*" {
			whowas $1;
		};
	} else {
		^on #-401 1 -"*";
	};
};

set auto_whowas on;

# BEEP_ON_MSG

addset beep_on_msg str {
	if ([$0] != [none]) {
		^on #-action 1 "*" {
			if (beep_on_msg == [all] || findw(action $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-channel_sync 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-ctcp 1 "*" {
			if (beep_on_msg == [all] || findw(ctcp $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_activity 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_connect 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_list 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_lost 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_offer 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-dcc_request 1 "*" {
			if (beep_on_msg == [all] || findw(dcc $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-join 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-leave 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-mail 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-mode 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-msg 1 "*" {
			if (beep_on_msg == [all] || findw(msgs $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-notice 1 "*" {
			if (beep_on_msg == [all] || findw(notices $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-numeric 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-oper_notice 1 "*" {
			if (beep_on_msg == [all] || findw(opnotes $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-pong 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-public 1 "*" {
			if (beep_on_msg == [all] || findw(public $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-server_notice 1 "*" {
			if (beep_on_msg == [all] || findw(snotes $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-wallop 1 "*" {
			if (beep_on_msg == [all] || findw(wallops $beep_on_msg) > -1) {
				beep;
			};
		};
		^on #-who 1 "*" {
			if (beep_on_msg == [all] || findw(crap $beep_on_msg) > -1) {
				beep;
			};
		};
	} else {
		fe (action channel_sync ctcp dcc_activity dcc_connect dcc_list dcc_lost dcc_offer dcc_request join leave mail mode msg notice numeric oper_notice pong public server_notice wallop who) bb {
			^on #-$bb 1 -"*";
		};
	};
};

set beep_on_msg none;

# COMMAND_MODE

addset command_mode bool {
	if ([$0] == [on]) {
		^on ^input "'*" {
			send $rest(1 $*);
		};
		^on ^input "/*" {
			sendline $*;
		};
		^on ^input "*" {
			sendline /$*;
		};
	} else {
		^on input -"'*";
		^on input -"/*";
		^on input -"*";
	};
};

set command_mode off;

# DCC_TIMEOUT

addset dcc_timeout int {
	^on #-timer 1 "*" {
		fe ($dccctl(refnums)) dd {
			if (time() - word(0 $dccctl(get $dd lasttime)) >= dcc_timeout) {
				dcc close $dccctl(get $dd type) $dccctl(get $dd user);
			};
		};
	};
};

set dcc_timeout 3600;

# FULL_STATUS_LINE

addset full_status_line bool {
	if ([$0] == [on]) {
		^set status_format $before(-1  $status_format);
		^set status_format1 $before(-1  $status_format1);
		^set status_format2 $before(-1  $status_format2);
	} else {
		^set status_format $status_format;
		^set status_format1 $status_format1;
		^set status_format2 $status_format2;
	};
};

set full_status_line on;

# NUM_OF_WHOWAS

addset num_of_whowas int;

set num_of_whowas 1;

# REVERSE_STATUS_LINE

addset reverse_status_line bool {
	if ([$0] == [on]) {
		^set status_format $after(1  $status_format);
		^set status_format1 $after(1  $status_format1);
		^set status_format2 $after(1  $status_format2);
	} else {
		^set status_format $status_format;
		^set status_format1 $status_format1;
		^set status_format2 $status_format2;
	};
};

set reverse_status_line on;

# SHOW_END_OF_MSGS

addset show_end_of_msgs bool {
	if ([$0] == [on]) {
		fe (219 232 262 315 318 347 349 365 366 368 369 374 394) ss {
			^on $ss -"*";
		};
	} else {
		fe (219 232 262 315 318 347 349 365 366 368 369 374 394) ss {
			^on ^$ss "*" #;
		};
	};
};

set show_end_of_msgs on;

# SHOW_WHO_HOPCOUNT

addset show_who_hopcount bool {
	if ([$0] == [on]) {
		^on who -"*";
	} else {
		^on ^who "*" {
			xecho -w $winchan($0) $[15]0 $[9]1 $[3]2 $3@$4 \($7-\);
		};
	};
};

set show_who_hopcount on;

# VERBOSE_CTCP

addset verbose_ctcp bool {
	if ([$0] == [on]) {
		^on ctcp -"*";
	} else {
		^on ^ctcp "*" #;
	};
};

set verbose_ctcp on;
