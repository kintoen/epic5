if (word(2 $loadinfo()) != [pf]) { load -pf $word(1 $loadinfo()); return; };

# If you want to rejoin your channels upon reconnecting or join some after a
# connect, use the autojoin script.

package reconnect;

addset auo_reconnect bool;
addset auto_reconnect_delay int;
set auto_reconnect_delay 1;
set auto_reconnect on;

alias _svkey (ref, void) {
  ^local gr;
  @ gr = servergroup($ref);
  if (gr == [<default>]) {
    return sv $ref;
  };
  return gr $gr;
};

on #-SERVER_STATUS 27 "% % %" {
  switch ($2) {
    # the server gets disconnected because of a socket error
    (EOF) (ERROR) {
      # if the server suddenly gains a group, we need to delete the old one
      _reconn_purge $0;
      # $1 == [CLOSING] && $2 == [ERROR] can happen if a there's a socket write error for finishing QUIT
      if ([$1] != [CLOSING] && getset(auto_reconnect) == [ON]) {
        @ :egr = encode($_svkey($0));
        @ reconn[$egr][channels] = [];
        @ reconn[$egr][keys] = [];
        ^local i;
        fe ($tolower($mychannels($0))) i {
          push reconn[$egr][channels] $i;
          xeval -s $0 {
            push reconn[$egr][keys] $key($i);
          };
        };
        @ reconn[$egr][timeout] = [$getset(auto_reconnect_delay) $0];
      };
    };
    # the server gets disconnected because user says so
    (CLOSING) {
      if ([$1] != [EOF] && [$1] != [ERROR]) {
        _reconn_purge $0;
      };
    };
    # the server gets deleted
    (DELETED) {
      _reconn_sweep $0;
    };
  };
};

alias _reconn_purge (ref, void) {
  @ :gr  = _svkey($ref);
  @ :egr = encode($gr);
  ^assign -reconn[$egr][timeout];
  ^assign -reconn[$egr][channels];
  ^assign -reconn[$egr][keys];
  if (word(0 $gr) == [gr]) {
    # it is a server, but it suddenly gained a group
    @ :str = encode(sv $ref);
    ^assign -reconn[$str][timeout];
    ^assign -reconn[$str][channels];
    ^assign -reconn[$str][keys];
  };
};

alias _reconn_sweep (ref, void) {
  ^local i,str,type,item,gr,svs;
  @ str = encode(sv $ref);
  ^assign -reconn[$str][timeout];
  ^assign -reconn[$str][channels];
  ^assign -reconn[$str][keys];

  foreach reconn i {
    @ str = decode($i);
    @ type = word(0 $str);
    @ item = word(1 $str);
    if (type == [sv]) {
      @ gr = servergroup($item);
      # it is a server, but it suddenly gained a group
      if (gr != [<default>]) {
        ^assign -reconn[$i][timeout];
        ^assign -reconn[$i][channels];
        ^assign -reconn[$i][keys];
      };
    } elif (type == [gr]) {
      @ svs = serverctl(GMATCH $item);
      # there are no servers || the only server is the one that's being deleted
      if (svs == [] || svs == ref) {
        ^assign -reconn[$i][timeout];
        ^assign -reconn[$i][channels];
        ^assign -reconn[$i][keys];
      };
    };
  };
};

timer -ref _reconn -repeat -1 -GENERAL 60 _reconn;
alias _reconn (void) {
  ^local i,win,found,str,type,item;
  foreach reconn i {
    @ str = decode($i);
    @ type = word(0 $str);
    @ item = word(1 $str);
    @ :minleft = word(0 $reconn[$i][timeout]);
    @ :lastsv = word(1 $reconn[$i][timeout]);
    @ minleft--;
    if (minleft > 0) {
      @ reconn[$i][timeout] = [$minleft $lastsv];
    } else {
      ^ASSIGN -reconn[$i][timeout];
      fe ($winrefs()) win {
        if (winserv($win) == lastsv) {
          PUSH found $win;
        };
      };
      if (found != []) {
        if (type == [gr]) {
          @ :next = nextserv($lastsv $item);
        } else {
          @ :next = lastsv;
        };
        if (next != -1) {
          fe ($found) j {
            window $j SERVER $next;
          };
        };
      };
    };
  };
};

alias rmreconns {
  ^local i,st;
  foreach reconn i {
    ^assign -reconn[$i][timeout];
    ^assign -reconn[$i][channels];
    ^assign -reconn[$i][keys];
  };
  fe ($serverctl(OMATCH *)) i {
    @ st = serverctl(GET $i STATUS);
    switch ($st) {
      (dns) (connecting) (registering) (syncing) (ssl_connecting) {
        disconnect $i;
      };
    };
  };
};

alias nextserv (ref, group, void) {
  if (group == [<default>]) {
    return -1;
  };
  @ :servers = serverctl(GMATCH $group);
  @ :num = numwords($servers);
  if (num == 0) {
    # can't happen
    return -1;
  };
  @ :found = findw($ref $servers);
  if (found == -1) {
    return $word(0 $servers);
  };
  @ num--;
  if (num == found) {
    return $word(0 $servers);
  } else {
    return $word(${found+1} $servers);
  };
};

#weirdo'2k6
