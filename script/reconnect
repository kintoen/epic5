if (word(2 $loadinfo()) != [pf]) { load -pf $word(1 $loadinfo()); return; };

package reconnect;

addset reconnect_time int;
set reconnect_time 1;

alias network (action, network, unused) {
  switch ($action) {
    (add) {
      @ :en = encode($network);
      if (en != []) {
        if (reconn[groups][$en]) {
          echo network $network already exists;
        } else {
          @ reconn[groups][$en] = 1;
          echo network $network added;
        };
      } else {
        echo not enough params. syntax: /network add <network>;
      };
    };
    (del) {
      @ :en = encode($network);
      if (en != []) {
        if (reconn[groups][$en]) {
          ^assign -reconn[groups][$en];
          ^assign -reconn[channels][$en];
          ^assign -reconn[keys][$en];
          echo network $network removed;
        } else {
          echo network $network doesn't exist;
        };
      } else {
        echo not enough params. syntax: /network del <network>;
      };
    };
    (list) {
      @ :j = 0;
      foreach reconn.groups i {
        @ j++;
        echo $decode($i);
      };
      if (j == 0) {
        echo no networks;
      };
    };
    (*) {
      echo syntax: /network [[add|del <name>]|list];
    };
  };
  ^assign -i;
};
on #-SERVER_STATUS 27 "% % %" {
  switch ($2) {
    (EOF) (ERROR) {
      @ :gr = encode($servergroup($0));
      if (reconn[groups][$gr]) {
        if ([$1] == [ACTIVE]) {
          @ reconn[channels][$gr] = [];
          @ reconn[keys][$gr] = [];
          fe ($tolower($mychannels($0))) i {
            push reconn[channels][$gr] $i;
            xeval -s $0 {
              push reconn[keys][$gr] $key($i);
            };
          };
        };
        @ reconn[timeout][$gr] = [$getset(reconnect_time) $0];
      };
    };
    (*) {
      if ([$2] == [CLOSING] && [$1] != [EOF] && [$1] != [ERROR]) {
        @ :gr = encode($servergroup($0));
        if (gr != []) {
          ^assign -reconn[timeout][$gr];
          ^assign -reconn[channels][$gr];
          ^assign -reconn[keys][$gr];
        };
      };
    };
  };
  ^assign -i;
};
timer -ref _reconn -repeat -1 -GENERAL 60 _reconn;
alias _reconn {
  foreach reconn.timeout i {
    @ :minleft = word(0 $reconn[timeout][$i]);
    @ :lastsv = word(1 $reconn[timeout][$i]);
    @ minleft--;
    if (minleft > 0) {
      @ reconn[timeout][$i] = [$minleft $lastsv];
    } else {
      ^ASSIGN -reconn[timeout][$i];
      @ :found = [];
      fe ($winrefs()) win {
        if (winserv($win) == lastsv) {
          PUSH found $win;
        };
      };
      if (found != []) {
        @ :next = nextserv($lastsv);
        if (next != -1) {
          fe ($found) j {
            window $j SERVER $next;
          };
        };
      };
    };
  };
  ^assign -win;
  ^assign -i;
};
alias nextserv (ref) {
  @ :gr = servergroup($ref);
  if (gr == [<default>]) {
    return -1;
  };
  @ :servers = serverctl(GMATCH $gr);
  @ :num = numwords($servers);
  if (num == 0) {
    return -1;
  };
  if (num == 1) {
    return $word(0 $servers);
  };
  @ :found = -1;
  @ :idx = 0;
  fe ($servers) i {
    if (i == ref) {
      @ found = idx;
      break;
    };
    @ idx++;
  };
  if (found == -1) {
    return -1;
  };
  @ num--;
  if (num == found) {
    return $word(0 $servers);
  } else {
    return $word(${found+1} $servers);
  };
  ^assign -i;
};
#weirdo'2k6
