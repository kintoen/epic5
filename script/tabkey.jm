# tabkey.jm: a full-featured tab key script for epic4
#
# this script features:
#
#   * target history cycling for /msg and /notice
#
#   * match possibility cycling (zsh-style completion)
#
#   * reverse cycling (ctrl + r)
#
#   * completion of command names, channel names, nicknames and file names
#
#   * shell-like completion for /exec
#
#   * proper handling of file names that contain spaces
#
#   * multi-server support
#
# sets this script uses:
#
#   NICK_COMPLETION_CHAR -- This character (or string of characters) will be
#                           appended to a nickname, if nick completion is
#                           performed as the first word of the input line.
#                           This is usually set to ':'.
#
#   TAB_HISTORY_CYCLE_SIZE -- This value determines how many nicknames will
#                             be held in the target history.
#
#   ZSH_STYLE_COMPLETION -- When there are multiple matchs possibilities for a
#                           word, you can cycle through the possibilities by
#                           hitting the tab key a 2nd time, if this is set on.
#
# note this script uses the serial number 50 for its serial hooks
#

# *** config variables ***
@nick_completion_char = []
@tab_history_cycle_size = 10
@zsh_style_completion = [OFF]


# *** global variables ***
@last_input_line = []
@match_index = -1
@match_history = []
@target_index = -2
@target_history = []


bind ^I parse_command do_tabkey
bind ^R parse_command do_cycling -1 $left($curpos() $L)

alias add_target (msg_cmd, target) {
	if (numwords($myservers()) > 1 && count(: $target) == 0 && left(1 $target) != [=]) {
		@:target = [${servernum()}:${target}]
	}

	@target_history = remw("$msg_cmd $target" $target_history)

	if (#target_history > ((tab_history_cycle_size * 2) -1)) {
		@target_history = restw(2 $target_history)
	}

	@target_index = #target_history - 2

	@push(target_history $msg_cmd)
	@push(target_history $target)
}

alias cycle_match (direction) {
	@:frag_start = current_fragment_start()

	if (frag_start == -1) {
		return
	}

	@:cur_pos = curpos()
	@:fragment = mid($frag_start ${cur_pos - frag_start} $L)

	if (mid($cur_pos 1 $L) == ["]) {
		parsekey forward_character
		parsekey backspace
	}

	if (index("$chr(32)" $fragment) == -1) {
		repeat $strlen($fragment) parsekey backspace
	} else {
		repeat ${strlen($fragment) + 1} parsekey backspace
	}

	@match_index += direction

	if (match_index == #match_history) {
		@match_index = 0
	} elsif (match_index < 0) {
		@match_index = #match_history - 1
	}

	@:new_match = word($match_index $match_history)

	if (index("$chr(32)" $new_match) == -1) {
		xtype -l $new_match
	} else {
		xtype -l "$new_match"

		parsekey backward_character
	}

	@last_input_line = left($curpos() $L)
}

alias cycle_msg (direction) {
	if (#target_history < 2) {
		return
	}

	@target_index += (direction * 2)

	if (target_index == #target_history) {
		@target_index = 0
	} elsif (target_index < 0) {
		@target_index = #target_history - 2
	}

	@:msg_cmd = word($target_index $target_history)
	@:msg_targ = word(${target_index + 1} $target_history)

	parsekey erase_line

	xtype -l /${msg_cmd} ${msg_targ}${chr(32)}

	@last_input_line = []
}

# current_fragment_start
#
# This function returns an index pointing to the beginning of the word that
# curpos() points to.  Why do this when there's indextoword() and
# wordtoindex()?  Because they don't work exactly as I'd like with quoted
# words (regardless of whether extractw is set).

alias current_fragment_start {
	@:i = 0
	@:last_space = 0
	@:last_quote = 0
	@:quotes = 0
	@:cur_pos = curpos()

	while (i < cur_pos) {
		@:char = mid($i 1 $L)

		if (char == [ ]) {
			@:last_space = i
		} elsif (char == ["]) {
			@:last_quote = i
			@:quotes++
		}

		@:i++
	}

	@:i++

	if (quotes % 2) {
		while (i < (@L + 1)) {
			if (mid($i 1 $L) == ["]) {
				return -1
			}

			@:i++
		}

		return ${last_quote + 1}
	} else {
		if (mid(${cur_pos - 1} 1 $L) == ["]) {
			return -1
		} else {
			if (last_space) {
				return ${last_space + 1}
			} else {
				return 0
			}
		}
	}
}

# do_cycling
#
# This function performs target history cycling, or match possibility cycling,
# if need be.
#
#  Returns: 1 if the input line should be parsed for completion
#           0 if it should not
#

alias do_cycling (direction, input_line) {
	if (L == []) {
		@cycle_msg($direction)
		return 0
	} elsif (encode($input_line) == encode($last_input_line)) {
		if (zsh_style_completion == [ON] && #match_history > 1) {
			@cycle_match($direction)
			return 0
		} else {
			return 0
		}
	} elsif (leftw(1 $L) == [/msg] || leftw(1 $L) == [/notice]) {
		if (#L == 2 && mid(${@L - 1} 1 $L) == [ ]) {
			@cycle_msg($direction)
			return 0
		}
	} else {
		return 1
	}
}

alias do_set (variable, value) {
	if (value == []) {
		^eval @:setval = $variable

		if (setval == []) {
			xecho -b No value for $variable has been set
		} else {
			xecho -b Current value of $variable is $setval
		}

		return
	}

	switch ($variable) {
		(NICK_COMPLETION_CHAR) {
			if (value == [<unset>]) {
				@nick_completion_char = []

				xecho -b Value of NICK_COMPLETION_CHAR set to <EMPTY>
			} else {
				@nick_completion_char = value

				xecho -b Value of NICK_COMPLETION_CHAR set to $value
			}
		}

		(TAB_HISTORY_CYCLE_SIZE) {
			if (!isnumber($value)) {
				xecho -b Value of TAB_HISTORY_CYCLE_SIZE must be numeric!
			} elsif (value < 1) {
				xecho -b Value of TAB_HISTORY_CYCLE_SIZE cannot be less than 1
			} else {
				@tab_history_cycle_size = value
				@target_history = rightw(${value * 2} $target_history)
				xecho -b Value of TAB_HISTORY_CYCLE_SIZE set to $value
			}
		}

		(ZSH_STYLE_COMPLETION) {
			if (value == [on]) {
				@zsh_style_completion = [ON]

				xecho -b Value of ZSH_STYLE_COMPLETION set to ON
			} elsif (value == [off]) {
				@zsh_style_completion = [OFF]

				xecho -b Value of ZSH_STYLE_COMPLETION set to OFF
			} else {
				xecho -b Value of ZSH_STYLE_COMPLETION must be ON or OFF!
			}
		}

		(*) {
			xecho -b I don't know how to handle "$variable"
		}
	}
}

alias do_tabkey {
	@:cur_pos = curpos()
	@:input_line = left($cur_pos $L)

	if (do_cycling(1 $input_line) == 0) {
		return
	}

	@:frag_start = current_fragment_start()

	if (frag_start == -1) {
		return
	}

	@:fragment = mid($frag_start ${cur_pos - frag_start} $L)
	@:fraglen = strlen($fragment)
	@:padding = []

	switch ($input_line) {
		(/dcc %) {
			@:matches = match_dcc($fragment)
			@match_history = matches

			if (#matches == 1) {
				@:padding = [ ]
			}
		}

		(/exec %) {
			@:matches = match_exec($fragment)
			@match_history = matches

			if (#matches == 1 && !isdirectory($matches)) {
				@:padding = [ ]
			}
		}

		(/dcc send % *)

		(/exec % *)

		(/load *)

		(/unload *) {
			@:matches = match_file($fragment)
			@match_history = matches

			if (#matches == 1 && !isdirectory($matches)) {
				@:padding = [ ]
			}
		}

		(/%) {
			@:matches = match_command($rest($input_line))
			@match_history = matches

			if (#matches == 1) {
				@:padding = [ ]
			}
		}

		(@%)

		(#%) {
			@:matches = match_chan($fragment)
			@match_history = matches

			if (#matches == 1) {
				@:padding = [ ]
			}
		}

		(%) {
			@:matches = match_nick($fragment)

			if (#matches == 1 && nick_completion_char != []) {
				@:padding = [$nick_completion_char ]
				@match_history = []
			} elsif (#matches > 1 && nick_completion_char != []) {
				@match_history = []

				fe ($matches) nickname {
					@push(match_history ${nickname}${nick_completion_char})
				}
			} else {
				@match_history = matches
			}
		}

		(*) {
			if (index(@# $fragment) == 0) {
				@:matches = match_chan($fragment)
				@match_history = matches

				if (#matches == 1) {
					@:padding = [ ]
				}
			} else {
				@:matches = match_nick($fragment)
				@match_history = matches

				if (#matches == 1) {
					@:padding = [ ]
				}
			}
		}
	}

	@last_input_line = input_line
	@match_index = -1
	@:match_prefix = prefix($matches)

	if (@match_prefix <= fraglen && #matches > 1) {
		xecho -c Possible matches:
		xecho -c -- $matches
		xecho -c
		return
	}

	if (match_prefix != []) {
		@:new_fragment = left($fraglen $match_prefix)

		if (encode($fragment) != encode($new_fragment)) {
			repeat $fraglen parsekey backspace

			xtype -l $new_fragment
		}
	}

	@:completion = rest($fraglen $match_prefix)

	if (index("$chr(32)" $fragment) == -1) {
		if (index("$chr(32)" $match_prefix) != -1) {
			if (mid($curpos() 1 $L) == ["]) {
				parsekey forward_character
				parsekey backspace
			}

			repeat $fraglen parsekey backspace

			if (mid(${curpos() - 1} 1 $L) == ["]) {
				parsekey backspace
			}

			xtype -l "$match_prefix"

			if (padding == []) {
				parsekey backward_character
			} else {
				@pad_input_line($padding)
			}
		} else {
			xtype -l $completion

			@pad_input_line($padding)
		}
	} else {
		xtype -l $completion

		if (padding == []) {
			if (mid($curpos() 1 $L) != ["]) {
				xtype -l "
				parsekey backward_character
			}
		} else {
			if (mid($curpos() 1 $L) == ["]) {
				parsekey forward_character
			} else {
				xtype -l "
			}

			@pad_input_line($padding)
		}
	}

	if (completion != []) {
		@last_input_line = []
	}
}

alias isdirectory (pathname) {
	@:statret = stat($pathname)
	@:file_type = left(1 $word(2 $statret))

	if (file_type & 4) {
		return 1
	} else {
		return 0
	}
}

alias isexe (pathname) {
	@:statret = stat($pathname)
	@:file_mode = word(2 $statret)
	@:file_type = left(1 $file_mode)
	@:permissions = right(3 $file_mode)
	@:user_perm = left(1 $permissions)
	@:group_perm = mid(1 1 $permissions)
	@:other_perm = right(1 $permissions)

	if (file_type == 1) {
		if ((user_perm & 1) || (group_perm & 1) || (other_perm & 1)) {
			return 1
		} else {
			return 0
		}
	} else {
		return 0
	}
}

alias match_chan (fragment) {
	return $pattern("${fragment}*" $mychannels())
}

alias match_command (fragment) {
	@:matches = []
	@:command_matches = getcommands(${fragment}*)

	@push(command_matches $aliasctl(alias pmatch ${fragment}*))

	fe ($command_matches) command {
		@push(matches /${command})
	}

	return $uniq($matches)
}

alias match_dcc (fragment) {
	@:dcc_cmds = [chat close closeall get list raw rename resume send]

	return $pattern(${fragment}% $dcc_cmds)
}

alias match_exec (fragment) {
	@:matches = []

	if (index(/ $fragment) == -1) {
		@:last_separator = 0
		@:next_separator = 0
		@:my_path = getenv(PATH)
		@:my_path_len = strlen($my_path)

		while (next_separator <= my_path_len) {
			if (mid($next_separator 1 $my_path) == [:]) {
				@:pathlen = next_separator - last_separator
				@:pathname = mid($last_separator $pathlen $my_path)

				@:file_matches = glob("${pathname}/${fragment}*")

				fe ($file_matches) filename {
					if (isexe($filename)) {
						@push(matches $after(-1 / $filename))
					}
				}

				@:last_separator = next_separator + 1
			}

			@:next_separator++
		}

		@:file_matches = glob("${fragment}*")

		fe ($file_matches) filename {
			if (isexe($filename) || isdirectory($filename)) {
				@push(matches $filename)
			}
		}
	} else {
		@:file_matches = glob("${fragment}*")

		fe ($file_matches) filename {
			if (isexe($filename) || isdirectory($filename)) {
				@push(matches $filename)
			}
		}
	}

	return $uniq($matches)
}

alias match_file (fragment) {
	return $glob("${fragment}*")
}

alias match_nick (fragment) {
	@:matches = pattern("${fragment}*" $onchannel())

	if (matches == []) {
		@:nick_list = []

		fe ($remw($C $mychannels())) nickname {
			@push(nick_list $onchannel($nickname))
		}

		fe ($notify(on)) nickname {
			@push(nick_list $nickname)
		}

		@:matches = pattern(${fragment}* $nick_list)
	}

	return $uniq($matches)
}

alias msg (target, message) {
	if (index(: $target) == -1) {
		//msg $target $message
	} else {
		@:refnum = before(: $target)
		@:new_target = after(: $target)

		if (servername($refnum) == [<none>]) {
			//msg $target $message
		} elsif (findw($target $mychannels()) > -1) {
			//msg $target $message
		} else {
			xeval -s $refnum {//msg $new_target $message}
		}
	}
}

alias notice (target, message) {
	if (index(: $target) == -1) {
		//notice $target $message
	} else {
		@:refnum = before(: $target)
		@:new_target = after(: $target)

		if (servername($refnum) == [<none>]) {
			//notice $target $message
		} elsif (findw($target $mychannels()) > -1) {
			//notice $target $message
		} else {
			xeval -s $refnum {//notice $new_target $message}
		}
	}
}

alias pad_input_line (padding) {
	if (mid(${curpos()} 1 $L) != padding) {
		xtype -l $padding
	}
}


# *** hooks ***

if (info(i) >= 225) {
	^on #^general_notice 50 "% *" {
		@add_target(notice $1)
	}
} else {
	^on #^raw_irc 50 "% NOTICE *" {
		@add_target(notice $2)
	}
}

on #^dcc_chat 50 "*" {
	@add_target(msg =$0)
}

on #^dcc_connect 50 "% CHAT *" {
	@add_target(msg =$0)
}

on #^msg 50 "*" {
	@add_target(msg $0)
}

on #^notice 50 "*" {
	@add_target(notice $0)
}

on #^send_action 50 "*" {
	if (!rmatch($0 #* &* +*) ) {
		@add_target(msg $0)
	}
}

on #^send_dcc_chat 50 "*" {
	@add_target(msg =$0)
}

on #^send_msg 50 "*" {
	@add_target(msg $0)
}

on #^send_notice 50 "*" {
	@add_target(notice $0)
}

on ^set "NICK_COMPLETION_CHAR *" {
	@do_set(NICK_COMPLETION_CHAR $1)
}

on ^set "TAB_HISTORY_CYCLE_SIZE *" {
	@do_set(TAB_HISTORY_CYCLE_SIZE $1)
}

on ^set "ZSH_STYLE_COMPLETION *" {
	@do_set(ZSH_STYLE_COMPLETION $1)
}
